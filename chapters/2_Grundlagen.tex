\chapter{Grundlagen}
In diesem Kapitel wird auf die Grundlagen von Domain-Driven Design und jQAssistant eingegangen. Dabei wird der Schwerpunkt auf die Definition der Domain-Driven Design Prinzipien gelegt. Anschließend wird die Funktionsweise und die Bedienung von jQAssistant erläutert.

\section{Einführung in Domain-Driven Design}
Das Domain-Driven Design besteht zu einem Großen teil aus dem Strategic Domain-Driven Design und dem Tactical Domain-Driven Design. Das Strategic Domain-Driven Design behandelt hauptsächlich die Methodik hinter dem Design- und Entwicklungsprozess. Das Tactical Domain-Driven Design hingegen erläutert Design Muster \cite{DDD:Holmstrom:2019}. Da für das Ziel dieser Arbeit hauptsächlich das Tactical Domain-Driven Design von relevanz ist, wird in diesem Abschnitt darauf der Schwerpunkt gelegt.

\begin{figure}[htbp] 
  \centering
     \includegraphics[width=1.0\textwidth]{gfx/DDD_Simple_Overview.png}
  \caption{Vereinfachter Überblick über die Muster-Sprache von Domain-Driven Design}
  \label{fig:DDD:pattern}
\end{figure}

In der Abbildung \ref{fig:DDD:pattern} \cite{DDD:Plod:2019} sind die Zusammenhänge der einzelnen Komponenten des Domain-Driven Design dargestellt.

\subsection{Domain}
Laut Evans ist eine Domain \glqq das Fachgebiet, auf das der Benutzer ein Programm anwendet \grqq{} \cite{DDD:Plod:2019}.

\subsection{Bounded Context}
Es wird empfohlen für jede Domain ein seperates Modell zu erstellen \cite{DDD:Avram:2007}. Der Bounded Context  definiert den Kontext dieses Modells, dadurch werden zum Beispiel der Umsetzungen wie Codebasen und dem Datenbankschemata Grenzen gesetzt \cite{DDD:Evans:2003}. 


\subsection{Ubiquitous Language}
Die Ubiquitous Language definiert die genutzten Sprache des Bounded Context \cite{DDD:Evans:2014, DDD:Plod:2019}. Die Abbildung \ref{fig:DDD:pattern} zeigt, dass diese Sprache das Modell der Domain beeinflusst und von den Begriffen des Bounded Context abhängt. Die Ubiquitous Language ist nicht unveränderlich und kann während dem Entwicklungsprozess angepasst werden. Daraus folgt, dass \glqq eine Änderung der Sprache eine Änderung des Modells ist \grqq{} \cite{DDD:Plod:2019}. Die Begriffe des Bounded Context können somit die Benennung Klassen, Methoden und Modulen beeinflussen.  

\subsection{Model-Driven Design}
In der Abbildung \ref{fig:DDD:pattern} sieht man, dass, neben dem Bounded Context und der Ubiquitous Language, das Model-Driven Design eine große Rolle spielt. Denn \glqq die enge Verknüpfung des Codes mit einem zugrunde liegenden Modell gibt dem Code einen Sinn und macht das Modell relevant\grqq{} \cite{DDD:Plod:2019}. Damit ist gemeint, dass die Definition des Modells im Model-Driven Design eine direkten Einfluss auf den Quellcode hat. 

In den nachfolgenden Abschnitten wird auf die Bestandteile des Model-Driven Design, welche in der Abbildung \ref{fig:DDD:pattern} zu sehen sind, eingegangen.

\subsubsection{Layered Architecture}
\begin{figure}
    \centering
    \includegraphics[width=0.5\textwidth]{gfx/DDD_Layer.pdf}
    \caption{Darstellung der Layered Architecture des Model-Driven Design}
    \label{fig:DDD:layer}
\end{figure}

Das Model-Driven Design unterteilt sich in die in Abbildung \ref{fig:DDD:layer} \cite{DDD:Evans:2003} gezeigten Schichten. Die oberste Schicht ist das User Interface. Sie ist für Präsentation von Inhalten sowie der Interpretation von Nutzereingaben zuständig \cite{DDD:Evans:2003}. Die Art des User Interface ist dabei irrelevant. 

Die Application Layer des Systems und koordiniert Aufgaben und delegiert die Arbeit an Domain-Objekte der nächsten Ebene \cite{DDD:Evans:2003}. Somit enthält die Application Layer keine Geschäftslogik, außerdem hält sie nicht den Status der Domain-Objekte \cite{DDD:Avram:2007}.

Die Domain Layer beinhaltet die Geschäftskonzepte, Informationen über die Geschäftslage und Geschäftsregeln \cite{DDD:Evans:2003}. Zudem wird in dieser Schicht das Datenmodell des Systems definiert. Evans beschreibt diese Schacht als \glqq the heart of business software\grqq{}\cite{DDD:Evans:2003}.

Die letzte Schicht beinhaltet die Infrastruktur des Systems. Sie wird zur Unterstützung der anderen Schichten benötigt und kann unter anderm die Persistierung der Domain oder das Versenden von Nachrichten beinhalten \cite{DDD:Evans:2003}.

Die Bausteinedes Model-Driven Design, in den nachfolgenden Abschnitten, sind jeweils einer der zuvor genannten Schicht zugeordnet.

\subsubsection{Entities}
\cite{DDD:Evans:2003}
\cite{DDD:Evans:2014, DDD:Plod:2019}
\cite{DDD:Avram:2007}
\cite{DDD:Rademacher:2018b}


\subsubsection{Value Objects}
\cite{DDD:Evans:2003}
\cite{DDD:Evans:2014, DDD:Plod:2019}
\cite{DDD:Avram:2007}
\cite{DDD:Rademacher:2018b}


\subsubsection{Aggregates}
\cite{DDD:Evans:2003}
\cite{DDD:Evans:2014, DDD:Plod:2019}
\cite{DDD:Avram:2007}
\cite{DDD:Rademacher:2018b}


\subsubsection{Factories}
\cite{DDD:Evans:2003}
\cite{DDD:Evans:2014, DDD:Plod:2019}
\cite{DDD:Avram:2007}
\cite{DDD:Rademacher:2018b}


\subsubsection{Repositories}
\cite{DDD:Evans:2003}
\cite{DDD:Evans:2014, DDD:Plod:2019}
\cite{DDD:Avram:2007}
\cite{DDD:Rademacher:2018b}


\subsubsection{Services}
\cite{DDD:Evans:2003}
\cite{DDD:Evans:2014, DDD:Plod:2019}
\cite{DDD:Avram:2007}
\cite{DDD:Rademacher:2018b}


\subsubsection{Domain Event}
\cite{DDD:Evans:2014, DDD:Plod:2019}
\cite{DDD:Avram:2007}
\cite{DDD:Rademacher:2018b}


\subsubsection{Modules}
\cite{DDD:Evans:2003}
\cite{DDD:Evans:2014, DDD:Plod:2019}
\cite{DDD:Avram:2007}
\cite{DDD:Rademacher:2018b}



\section{Einführung in jQAssistant}
Zur Analyse des bestehenden Java-Systems wird, in dieser Arbeit, das Analyse-Werkzeug jQAssistant verwendet. Das Ziel von jQAssistant ist \glqq die Zerlegung eines komplexen Ganzen in eine Menge beherrschbarer Einheiten und die Definition der Beziehungen zwischen diesen.\grqq{}\cite{jQA:Mahler:2015} Dafür bietet jQAssistant die Möglichkeit Java-Systeme auf struktureller Ebene, anhand von projektspezifische Regeln, zu analysieren \cite{jQA:Buschmais:2019}. Das bedeutet jQAssistant bietet die Möglichkeit Java-Artefakte in ihre kleinsten Elemente, wie Felder von Klassen sowie Methoden und ihre Parameter, zu unterteilen. Außerdem werden auch die Beziehungen und Abhänigkeiten zwischen den Elementen erfasst.

Beim Analysieren werden verschiedene jQAssistant Plugins ausgeführt. Jedes Plugin besteht aus zwei Teilen, dem Scanner und verschiedenen Regeln. Der Scanner extrahiert die Daten aus dem Java-Artefakt und speicher diese in der Neo4j Graphdatenbank. Anschließende werden auf diese Daten verschiedenen Regeln zur Datenanreicherung ausgeführt.\cite{jQA:Muller:2018} So können zum Beispiel Abhänigkeiten erkannt und modelliert werden. 

\subsection{Persistierung der Analysedaten in einer Neo4j-Datenbank}
Die Daten in der Neo4j-Datenbank sind als Knoten modelliert. Jeder Knoten verfügt über Attribute, welche die Eigenschaften des Knotens beschreiben, zudem sind die einzelnen Konten mit Kanten verbunden welche die Beziehungen modellieren \cite{jQA:Muller:2018, jQA:Mahler:2015}.

\begin{lstlisting}[caption={Cypher-Abfrage zum filtern aller Klassen in einem bestimmten Package},label=lst:cypher]
    MATCH (package:Package)-[:CONTAINS]->(file:File) 
    WHERE package.fqn = "org.junit" AND file:Class
    RETURN file as Klassen
\end{lstlisting}

Auf diese Analysedaten kann mithilfe der Abfragesprache Cypher zugegriffen werden \cite{jQA:Muller:2018}. In \ref{lst:cypher} ist eine solche Abfrage zu sehen. Wie man an dieser Anfrage sieht, besteht eine Cypher-Abfrage auf drei Bausteinen. In der ersten Zeile wird definiert welche Knoten, mit welcher Beziehungen, berücksichtigt werden sollen. In diesem Fall sind alle Packages interessant welche einen oder mehrere Dateien beinhalten. In der zweiten Zeile wird näher spezifiziert welche Packages und welche Dateien relevant sind. In diesem Beispiel soll nur das Package mit dem Fully Qualified Name \glqq org.junit\grqq{} in Verbindung mit Java-Klassen berücksichtigt werden. Die letzte Zeile der Abfrage gibt anschließend an, was zurückgegeben werden soll, in diesem Fall alle Klassen die im Package \glqq org.junit\grqq{} enthalten sind.

Für die Verwendung von Cypher-Abfrage aus Java-Quellcode heraus kann eine Representational State Transfer Schnittstelle oder ein Java Database Connectivity Treiber verwendet werden. Die Representational State Transfer Schnittstelle allerdings hat den Nachteil, dass durch die Netzwerkkommunikation Zeit verloren geht. Mit dem Java Database Connectivity Treiber hingegen kann direkt auf der Datenbank eine Cypher-Abfrage ausgeführt werden. 

\subsection{Verwendung von jQAssistant}
jQAssistant steht dem Nutzer in drei verschiedenen Ausführungen zur Verfügung. Die erste Variante ist die Verwendung eins Maven Plugins, dabei kann der Scan des Projekts direkt aus dem Projekt heraus ausgeführt werden. Dafür ist es allerdings notwendig, dass das Projekt mit Maven verwaltet wird.

Wenn das Projekt nicht mit Maven verwaltet wird oder nur als Archiv zur Verfügung steht, bietet sich das Command Line Tool an. Dieses Werkzeug akzeptiert die Java-Projekte in den drei üblichen Formaten Java Archive (JAR), Enterprise Archive (EAR) und Web Application Archive (WAR). Es bietet die Möglichkeit mehrere Archive gleichzeitig zu analysieren.

Am einfachsten lässt sich jQAssistant mit einem Docker-Container ausführen. Dafür wird ein offizielles Docker-Image zur Verfügung gestellt. Dieser Docker-Container beinhaltet Command Line Tool, allerdings muss dafür dieses nicht auf dem ausführenden System vorhanden sein. Für die Umsetzung dieser Arbeit wurde die Methode mit dem Docker-Container ausgewählt, da es eine einfache Bedienung ermöglicht.