\chapter{Architekturanalyse von Java Systemen auf Basis von Domain-Driven Design}
\label{ch:analyse}
Diese Kapitel behandelt die Umsetzung der Architekturanalyse. Es wird darauf eingegangen anhand welcher Merkmale Domain-Driven Design Bausteine erkannt werden können.

\section{Erkennungsmerkmale der Domain-Driven Design Artefakte}
\label{sec:analyse:characteristics}
Sobald ein Java-System mit jQAssistant analysiert wurde, müssen die einzelnen Java-Artefakte analysiert werden. Dabei müssen die Artefakte den richtigen Domain-Driven Design Bausteinen zugeordnet werden. In diesem Abschnitt wird erläutert anhand von welchen Merkmalen die Domain-Driven Design Bausteine erkannt werden können.

\subsection{Entities}
\label{sec:analyse:characteristics:entity}
Bei dem Auffinden von Entities muss darauf Wert gelegt werden, ob es sich, bei dem Artefakt, um ein Bestandteil des Datenmodells handelt. 

\begin{figure}[H] 
    \centering
    \includegraphics[width=0.3\textwidth]{gfx/characteristics/Entity.pdf}
    \caption{Beispiel für eine Entity}
    \label{fig:analyse:characteristics:entity}
\end{figure}

In der Abbildung \ref{fig:analyse:characteristics:entity} ist ein möglicher Kandidat für eine Entity zusehen. Anhand dieses Beispiels werden die Merkmale von Entities veranschaulicht.

Wie bereits in dem Abschnitt \ref{sec:basics:ddd:mdd} erläutert, sind Entities die einzigen Artefakte welche eine eigene Identität besitzen. Daher kann das in Abbildung \ref{fig:analyse:characteristics:entity} gezeigte Beispiel, ohne weitere Einwende, als Entity klassifiziert werden. Wenn eine Klasse keine Identität besitzt, muss sie näher betrachtet werden um herauszufinden, ob es sich um eine Entity handelt. 

Ein weiteres Merkmal ist das Vorhandensein von Gettern und Settern, also Methoden zum Lesen und Schreiben von Attributen. Typischerweise besitzt eine Entity für die meisten Attribut eine solche Methode. Auch dieses Merkmal ist bei dem Beispiel in der Abbildung \ref{fig:analyse:characteristics:entity} erfüllt.

\subsection{Value Objects}
\label{sec:analyse:characteristics:value_object}
\begin{figure}[H] 
    \centering
    \includegraphics[width=0.25\textwidth]{gfx/characteristics/Value_Object.pdf}
    \caption{Beispiel für ein Value Object}
    \label{fig:analyse:characteristics:value_object}
\end{figure}

Die Merkmale von Value Objects sind denen der Entities sehr ähnlich. Sie unterscheiden sich allerdings in zwei entscheiden Punkten. Diese beiden Unterscheide können anhand der Klasse \texttt{Adresse} aus der Abbildung \ref{fig:analyse:characteristics:value_object} näher aufgezeigt werden.

Wenn man die Klasse \texttt{Adresse} auf die Erfüllung von Entity Merkmale überprüft, fällt direkt auf, dass sie keine Identität besitzt aber trotzdem ein Datenmodell repräsentiert. In solchen Fällen kann es sich um Value Object handeln.

Damit die Klasse eindeutig als Value Object identifiziert werden kann, müssen die Attribute der Klasse näher betrachtet werden. Denn wenn eine Klasse keine Entity ist und nur Attribute vom Typ eines Standard Datentyp oder anderer Value Objects besitzen, handelt es sich sehr wahrscheinlich um ein Value Object.

\subsection{Aggregate Roots}
\label{sec:analyse:characteristics:aggregate}
Sobald das Datenmodell einer Domain identifiziert und in Entities sowie Value Objects unterteilt wurde, müssen den Domains Aggregate Roots zugeordnet werden \cite{DDD:Vernon:2013}. Wie bereits in Abschnitt \ref{sec:basics:ddd:mdd:aggregate} erläutert können nur Entities die Rolle als Aggregate Root einnehmen.

\begin{figure}[H] 
    \centering
    \includegraphics[width=0.7\textwidth]{gfx/characteristics/Aggregate_Root.pdf}
    \caption{Beispiel für eine Aggregate Root}
    \label{fig:analyse:characteristics:aggregate}
\end{figure}

In der Abbildung \ref{fig:analyse:characteristics:aggregate} ist ein vereinfachtes Datenmodell aufgezeigt. In diesem Datenmodell gibt es nur zwei mögliche Kandidaten für die Aggregate Root, nämlich die Klassen \texttt{Haus} und \texttt{Mieter}. Bei der Entscheidung welche Klasse als Aggregate Root ausgewählt wird, spielen die Abhängigkeiten der Klassen eine entscheidende Rolle \cite{DDD:Vernon:2013}. Für jede Klasse wird gezählt von wie vielen Klassen sie abhängig ist. In diesem Beispiel ist die Klasse \texttt{Mieter} von einer Klasse abhängig. Die Klasse \texttt{Haus} besitzt allerdings keine Abhängigkeiten und wird daher als Aggregate Root ausgewählt.

\subsection{Factories}
\label{sec:analyse:characteristics:factory}
\begin{figure}[H] 
    \centering
    \includegraphics[width=0.3\textwidth]{gfx/characteristics/Factory.pdf}
    \caption{Beispiel für eine Factory}
    \label{fig:analyse:characteristics:factory}
\end{figure}

Die Abbildung \ref{fig:analyse:characteristics:factory} zeigt die Factory \texttt{HausFactory}. Anhand dieses Beispiels lässt sich gut aufzeigen, durch welche Merkmale eine Factory erkannt werden kann. 

An oberster Stelle steht die Benennung des Artefakts. Denn meistens enden die Namen von Factories mit \glqq Factory\grqq{}. Aber auch Repositories als Attribute und Methoden mit denen Entity Instanzen erstellt werden weisen auf mögliche Factories hin.

\subsection{Repositories}
\label{sec:analyse:characteristics:repository}
\begin{figure}[H] 
    \centering
    \includegraphics[width=0.3\textwidth]{gfx/characteristics/Repository.pdf}
    \caption{Beispiel für ein Repository}
    \label{fig:analyse:characteristics:repository}
\end{figure}

Bei Repositories läuft der Erkennungsprozess sehr ähnlich zu dem von Factories ab. Auch hier kann der Name des möglichen Repositories dabei helfen. Wie das Artefakt \texttt{HausRepository} aus der Abbildung \ref{fig:analyse:characteristics:repository} enden meistens die Namen von Repositories mit \glqq Repository\grqq{}. 

Zusätzlich zum Namen des Repositories können die Methoden weiterhelfen. Grundsätzlich sollten Repositories die Hauptoperationen von Datenbanken realisieren. Zu diesen Operationen zählen das Erzeugen, Lesen, Aktualisieren und Löschen von Instanzen.

\subsection{Domain Events}
\label{sec:analyse:characteristics:event}
Wie bereits in Abschnitt \ref{sec:basics:ddd:mdd:event} beschrieben, zeichnen sich Domain Events durch zwei Merkmale aus. Zum einen besitzen sie ein Attribut welches den Auslösungszeitpunkt des Domain Events und ein zweites Attribut welches die Identität der beteiligten Entity repräsentiert.

\begin{figure}[H] 
    \centering
    \includegraphics[width=0.3\textwidth]{gfx/characteristics/Domain_Event.pdf}
    \caption{Beispiel für ein Domain Event}
    \label{fig:analyse:characteristics:event}
\end{figure}

Die Klasse \texttt{HausVerkauf} aus der Abbildung \ref{fig:analyse:characteristics:event} weißt die beiden oben genannten Merkmale auf. In selten Fällen in denen diese Merkmale nicht zur Erkennung eines Domain Events ausreichen, kann es hilfreich sein den Namen der Klasse näher zu betrachten. Denn meistens beinhaltet dieser den Namen der Entity welcher das Domain Event zugeordnet ist.

\subsection{Services}
\label{sec:analyse:characteristics:service}
Um eine Service zu erkennen muss zwischen Domain und Application Services unterschieden werden, da sie unterschiedliche Merkmale aufweisen.

\subsubsection{Domain Services}
\label{sec:analyse:characteristics:service:domain}
\begin{figure}[H] 
    \centering
    \includegraphics[width=0.3\textwidth]{gfx/characteristics/Domain_Service.pdf}
    \caption{Beispiel für ein Domain Service}
    \label{fig:analyse:characteristics:domain}
\end{figure}

Wie in Abbildung \ref{fig:analyse:characteristics:domain} zu erkennen ist besitzen Domain Services meistens die Instanz eines Repositories als Attribut. Ähnlich wie beim Domain Event beinhalten auch Domian Servcies häufig den Namen der Entity in ihrem eigenen Namen. Abgesehen von diesen beiden Merkmalen verfügen Domain Services nur über Methoden welche Geschäftslogik enthalten.

\subsubsection{Application Services}
\label{sec:analyse:characteristics:service:application}
\begin{figure}[H] 
    \centering
    \includegraphics[width=0.3\textwidth]{gfx/characteristics/Application_Service.pdf}
    \caption{Beispiel für ein Application Service}
    \label{fig:analyse:characteristics:application}
\end{figure}

Im Gegensatz zu Domain Services besitzen Application Services keine Repository-Instanz und sind auch nicht einer Entity zugeordnet. Meistens beinhaltet der Name des Applictaion Services, wie in der Abbildung \ref{fig:analyse:characteristics:application}, \glqq Applictaion\grqq{}. Doch wenn das nicht der Fall ist erkennt man Application Services sehr leicht an der Methode \texttt{main(java.lang.String[])}.

\subsection{Infrastruktur}
\label{sec:analyse:characteristics:infrastructure}
Alle vorher nicht zugeordneten Artefakte werden der Infrastrukturebene zugeordnet, da sie keine Geschäftslogik enthalten und auch kein Teil des Datenmodells sind.