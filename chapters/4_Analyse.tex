\chapter{Architekturanalyse auf Basis von Domain-Driven Design}
\label{ch:analyse}
Dieses Kapitel behandelt die Umsetzung der Architekturanalyse. Es wird darauf eingegangen anhand welcher Merkmale Domain-Driven Design Bausteine erkannt werden können.

\section{Erkennung von Domain-Driven Design Artefakten}
\label{sec:analyse:characteristics}
Sobald ein Java-System mit jQAssistant analysiert wurde, müssen die einzelnen Java-Artefakte analysiert werden. Dabei müssen die Artefakte den richtigen Domain-Driven Design Bausteinen zugeordnet werden. In diesem Abschnitt wird erläutert, anhand welcher Merkmale die Domain-Driven Design Bausteine erkannt werden können und wie dies umgesetzt wird.

\subsection{Entities}
\label{sec:analyse:characteristics:entity}
Bei dem Auffinden von Entities muss darauf geachtet werden, ob es sich bei dem Artefakt um ein Bestandteil des Datenmodells handelt. 

\begin{figure}[H] 
    \centering
    \includegraphics[width=0.3\textwidth]{gfx/characteristics/Entity.pdf}
    \caption{Beispiel für eine Entity}
    \label{fig:analyse:characteristics:entity}
\end{figure}

In der \autoref{fig:analyse:characteristics:entity} ist ein möglicher Kandidat für eine Entity zu sehen. Anhand dieses Beispiels werden die Merkmale von Entities veranschaulicht.

Wie bereits in dem \autoref{sec:basics:ddd:mdd} erläutert, sind Entities die einzigen Artefakte welche eine eigene Identität besitzen. Daher kann das in \autoref{fig:analyse:characteristics:entity} gezeigte Beispiel, ohne weitere Einwände, als Entity klassifiziert werden. Wenn eine Klasse keine Identität besitzt, muss sie näher betrachtet werden um herauszufinden, ob es sich um eine Entity handelt. 

Ein weiteres Merkmal ist das Vorhandensein von Gettern und Settern, also Methoden zum Lesen und Schreiben von Attributen. Typischerweise besitzt eine Entity für die meisten Attribut eine solche Methode. Auch dieses Merkmal ist bei dem Beispiel in der \autoref{fig:analyse:characteristics:entity} erfüllt.

\begin{lstlisting}[float, caption={Überprüfung ob es sich um eine Entity handelt}, captionpos=b, label=lst:analyse:characteristics:entity, language=my_java]
private boolean isEntity() {
  for (Field field : this.artifact.getFields()) {
    if (isConstant(field)) {
      return false;
    } else if (Field.isId(field)) {
      return true;
    }
  }
  return !this.artifact.getFields().isEmpty()
    && containsModelMethods()
    && !containsEntityName();
}

private boolean containsModelMethods() {
  long constructors = artifact.getMethods().stream()
    .filter(method -> method.getName().equalsIgnoreCase("<init>"))
    .count();
  return artifact.getMethods().isEmpty()
    || constructors == artifact.getMethods().size()
    || containsEqualsOrHashCode()
    || containsGetterOrSetter();
}
\end{lstlisting}
Die Methode \texttt{isEntity} aus \autoref{lst:analyse:characteristics:entity} wird zur Analyse von Artefakten basierend der Merkmale von Entities verwendet. Von der zweiten bis zur achten Zeile werden die Attribute des Artefakts analysiert. 

Nachdem die Attribute analysiert wurden, werden die Methoden untersucht. Dies geschieht in der zweiten Methode \texttt{containsModelMethods}. Die Methode überprüft, wie bereits beschrieben, das Vorhandensein von Gettern und Settern sowie weitere Merkmale. Das Fehlen von Methoden oder der ausschließliche Besitz von Konstruktoren ist ein weiteres Merkmal von Entities. Diese Merkmale wurden in den Zeilen 15 bis 19 realisiert. Außerdem wird in der 20. Zeile das Artefakt überprüft, ob es die beiden, für Entities typischen, Methoden \texttt{equals} und \texttt{hashCode} besitzt.

\subsection{Value Objects}
\label{sec:analyse:characteristics:value_object}
Die Merkmale von Value Objects sind denen der Entities sehr ähnlich. Sie unterscheiden sich allerdings in zwei entscheiden Punkten. Diese beiden Unterschiede können anhand der Klasse \texttt{Adresse} aus der \autoref{fig:analyse:characteristics:value_object} näher aufgezeigt werden.

\begin{figure}[H] 
    \centering
    \includegraphics[width=0.3\textwidth]{gfx/characteristics/Value_Object.pdf}
    \caption{Beispiel für ein Value Object}
    \label{fig:analyse:characteristics:value_object}
\end{figure}

Wenn man die Klasse \texttt{Adresse} auf die Erfüllung von Entity Merkmale überprüft, fällt direkt auf, dass sie keine Identität besitzt aber trotzdem ein Datenmodell repräsentiert. In solchen Fällen kann es sich um Value Object handeln.

Damit die Klasse eindeutig als Value Object identifiziert werden kann, müssen die Attribute der Klasse näher betrachtet werden. Denn wenn eine Klasse keine Entity darstellt und nur Attribute vom Typ eines Standard Datentyp oder anderer Value Objects besitzt, handelt es sich sehr wahrscheinlich um ein Value Object.

\begin{lstlisting}[caption={Überprüfung ob es sich um ein Value Object handelt}, captionpos=b, label=lst:analyse:characteristics:value_object, language=my_java]
private boolean isValueObject() {
  int ctr = 0;
  for (Field field : artifact.getFields()) {
    if (isInvalidValueObjectField(field)) {
      return false;
    } else if (field.getType().startsWith("java.")
        || field.getType().contains(structure.getPath())) {
      ctr++;
    }
  }
  return !this.artifact.getFields().isEmpty()
    && (ctr == this.artifact.getFields().size()
        || containsModelMethods());
}

private boolean isInvalidValueObjectField(Field field) {
  return isId(field)
    || isConstant(field)
    || isRepositoryOrFactory(field);
}
\end{lstlisting}

Die gerade erläuterten Merkmale von Value Objects wurden durch die Methode \texttt{isValueObject} aus \autoref{lst:analyse:characteristics:value_object} realisiert. Zusätzlich zu den bereits genannten Merkmalen für Attribute, wurden in der zweiten Methode \texttt{isInvalidValueObjectField} weitere Ausschlusskriterien definiert. Zum Beispiel sollte ein Value Object keine Instanz eines Repositories oder einer Factory besitzen. Auch Konstanten sind für Value Objects eher untypisch. 

Für die Analyse der Methoden des Artefakts wird erneut die Methode \texttt{containsModelMethods} verwendet. Es handelt sich dabei um die bereits beschriebene Methode aus \autoref{lst:analyse:characteristics:entity} zur Analyse von Entities.

\subsection{Aggregate Roots}
\label{sec:analyse:characteristics:aggregate}
Sobald das Datenmodell einer Domain identifiziert und in Entities sowie Value Objects unterteilt wurde, müssen den Domains Aggregate Roots zugeordnet werden \cite{DDD:Vernon:2013}. Wie bereits in \autoref{sec:basics:ddd:mdd:aggregate} erläutert, können nur Entities die Rolle als Aggregate Root einnehmen.

\begin{figure}[H] 
    \centering
    \includegraphics[width=0.65\textwidth]{gfx/characteristics/Aggregate_Root.pdf}
    \caption{Beispiel für eine Aggregate Root}
    \label{fig:analyse:characteristics:aggregate}
\end{figure}

In der \autoref{fig:analyse:characteristics:aggregate} ist ein vereinfachtes Datenmodell aufgezeigt. In diesem Datenmodell gibt es nur zwei mögliche Kandidaten für die Aggregate Root, nämlich die Klassen \texttt{Haus} und \texttt{Mieter}. Bei der Entscheidung welche Klasse als Aggregate Root ausgewählt wird, spielen die Abhängigkeiten der Klassen eine entscheidende Rolle \cite{DDD:Vernon:2013}. Für jede Klasse wird gezählt wie vielen Klassen von ihr abhängig sind. In diesem Beispiel ist nur eine Klasse von der Klasse \texttt{Mieter} abhängig, nämlich die Klasse \texttt{Haus}. Von der Klasse \texttt{Haus} ist allerdings keine andere Klasse abhängig. Deshalb wird die Klasse \texttt{Haus} als Aggregate Root ausgewählt.

\begin{lstlisting}[caption={Finden von möglichen Kandidaten für die Aggregate Root}, captionpos=b, label=lst:analyse:characteristics:aggregate, language=my_java]
private ArrayList<Class> getEntityWithMinimalDependencies(ArrayList<Class> entities) {
  ArrayList<Class> result = new ArrayList<>();
  result.add(entities.get(0));
  int highscore = entities.get(0).getUsed().size();

  for (int i = 1; i < entities.size(); i++) {
    if (entities.get(i).getUsed().size() == highscore) {
      result.add(entities.get(i));
    } else if (entities.get(i).getUsed().size() < highscore) {
      highscore = entities.get(i).getUsed().size();
      result = new ArrayList<>();
      result.add(entities.get(i));
    }
  }
  return result;
}
\end{lstlisting}

Die Methode \texttt{getEntityWithMinimalDependencies} aus \autoref{lst:analyse:characteristics:aggregate} sucht aus einer gegebenen Liste von Entities die Kandidaten heraus.

\subsection{Factories}
\label{sec:analyse:characteristics:factory}
\begin{figure}[H] 
    \centering
    \includegraphics[width=0.3\textwidth]{gfx/characteristics/Factory.pdf}
    \caption{Beispiel für eine Factory}
    \label{fig:analyse:characteristics:factory}
\end{figure}

Die \autoref{fig:analyse:characteristics:factory} zeigt die Factory \texttt{HausFactory}. Anhand dieses Beispiels lässt sich gut aufzeigen, durch welche Merkmale eine Factory erkannt werden kann. 

An oberster Stelle steht die Benennung des Artefakts. Denn meistens enden die Namen von Factories mit \glqq Factory\grqq{}. Aber auch Repositories als Attribute und Methoden mit denen Entity Instanzen erstellt werden, weisen auf mögliche Factories hin.

\subsection{Repositories}
\label{sec:analyse:characteristics:repository}
\begin{figure}[H] 
    \centering
    \includegraphics[width=0.3\textwidth]{gfx/characteristics/Repository.pdf}
    \caption{Beispiel für ein Repository}
    \label{fig:analyse:characteristics:repository}
\end{figure}

Bei Repositories läuft der Erkennungsprozess sehr ähnlich zu dem von Factories ab. Auch hier kann der Name des möglichen Repositories dabei helfen. Wie das Artefakt \texttt{HausRepository} aus der \autoref{fig:analyse:characteristics:repository} enden, wenn bei der Entwicklung Namenskonventionen eingehalten wurden, die Namen von Repositories mit \glqq Repository\grqq{}. 

Zusätzlich zum Namen des Repositories können die Methoden weiterhelfen. Grundsätzlich sollten Repositories die Hauptoperationen von Datenbanken realisieren. Zu diesen Operationen zählen das Erzeugen, Lesen, Aktualisieren und Löschen von Instanzen.

\subsection{Domain Events}
\label{sec:analyse:characteristics:event}
Wie bereits in \autoref{sec:basics:ddd:mdd:event} beschrieben, zeichnen sich Domain Events durch zwei Merkmale aus. Zum einen besitzen sie ein Attribut welches den Auslösungszeitpunkt des Domain Events und ein zweites Attribut welches die Identität der beteiligten Entity repräsentiert.

\begin{figure}[H] 
    \centering
    \includegraphics[width=0.3\textwidth]{gfx/characteristics/Domain_Event.pdf}
    \caption{Beispiel für ein Domain Event}
    \label{fig:analyse:characteristics:event}
\end{figure}

Die Klasse \texttt{HausVerkauf} aus der \autoref{fig:analyse:characteristics:event} weist die beiden oben genannten Merkmale auf. In seltenen Fällen, in denen diese Merkmale nicht zur Erkennung eines Domain Events ausreichen, kann es hilfreich sein den Namen der Klasse näher zu betrachten. Denn meistens beinhaltet dieser den Namen der Entity, welcher das Domain Event zugeordnet ist.

\begin{lstlisting}[caption={Überprüfung ob es sich um ein Domain Event handelt}, captionpos=b, label=lst:analyse:characteristics:event, language=my_java]
private boolean isDomainEvent() {
  boolean containsTimestamp = false;
  boolean containsIdentity = false;

  for (Field field : this.artifact.getFields()) {
    if (field.getName().contains("time")
        || field.getName().contains("date")
        || field.getType().contains("java.time.")) {
      containsTimestamp = true;
    } else if (!field.getName().equalsIgnoreCase("id")
        && field.getName().toUpperCase().endsWith("ID")) {
      containsIdentity = true;
    }
  }
  return containsTimestamp && containsIdentity;
}
\end{lstlisting}

Die Methode \texttt{isDomainEvent} aus \autoref{lst:analyse:characteristics:event} zeigt die Implementierung der beiden Merkmale von Domain Events. 

\subsection{Services}
\label{sec:analyse:characteristics:service}
Um einen Service zu erkennen muss zwischen Domain und Application Services unterschieden werden, da sie unterschiedliche Merkmale aufweisen.

\subsubsection{Domain Services}
\label{sec:analyse:characteristics:service:domain}
\begin{figure}[H] 
    \centering
    \includegraphics[width=0.3\textwidth]{gfx/characteristics/Domain_Service.pdf}
    \caption{Beispiel für ein Domain Service}
    \label{fig:analyse:characteristics:domain}
\end{figure}

Wie in \autoref{fig:analyse:characteristics:domain} zu erkennen ist, besitzen Domain Services meistens die Instanz eines Repositories als Attribut. Ähnlich wie beim Domain Event beinhalten auch Domian Servcies häufig den Namen der Entity in ihrem eigenen Namen. Abgesehen von diesen beiden Merkmalen verfügen Domain Services nur über Methoden welche Geschäftslogik enthalten.

\begin{lstlisting}[caption={Überprüfung ob es sich um einen Service handelt}, captionpos=b, label=lst:analyse:characteristics:service, language=my_java]
private boolean isService() {
  for (Field field : this.artifact.getFields()) {
    if (field.getType().contains(REPOSITORY)) {
      return true;
    }
  }
  return containsEntityName();
}
\end{lstlisting}

Die Methode \texttt{isService} aus \autoref{lst:analyse:characteristics:service} überprüft die zuvor genannten Merkmale und gibt \texttt{true} zurück wenn es sich bei dem Artefakt um einen Service handelt.

\subsubsection{Application Services}
\label{sec:analyse:characteristics:service:application}

\begin{figure}[H] 
    \centering
    \includegraphics[width=0.3\textwidth]{gfx/characteristics/Application_Service.pdf}
    \caption{Beispiel für ein Application Service}
    \label{fig:analyse:characteristics:application}
\end{figure}

Im Gegensatz zu Domain Services besitzen Application Services keine Instanz eines Repositories und sind auch nicht einer Entity zugeordnet. Meistens beinhaltet der Name des Applictaion Services, wie in der \autoref{fig:analyse:characteristics:application}, den Substring \glqq Applictaion\grqq{}. Doch wenn das nicht der Fall ist, erkennt man Application Services sehr leicht an der Methode \texttt{main(String[])}. Die Überprüfung dieses Merkmals wurde mit der Methode \texttt{isApplicationService} aus \autoref{lst:analyse:characteristics:service:application} realisiert.

\begin{lstlisting}[caption={Überprüfung ob es sich um einen Application Service handelt}, captionpos=b, label=lst:analyse:characteristics:service:application, language=my_java]
private boolean isApplicationService() {
  for (Method method : this.artifact.getMethods()) {
    if (method.getName().equalsIgnoreCase("main")) {
      return true;
    }
  }
  return false;
}
\end{lstlisting}

\subsection{Infrastruktur}
\label{sec:analyse:characteristics:infrastructure}
Alle vorher nicht zugeordneten Artefakte werden der Infrastrukturebene zugeordnet, da sie keine Geschäftslogik enthalten und auch kein Teil des Datenmodells sind.