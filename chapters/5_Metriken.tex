\chapter{Architekturbewertung von Java-Systemen}
\label{ch:rating}
Diese Kapitel erläutert die Architekturbewertung eines Java-Systems. Zu Beginn werden die Bewertungskriterien für die eingelesenen Bausteine vorgestellt. Anschließend werden zwei Metriken vorgestellt, mit deren Hilfe der Zustand eines Java-Systems bewertet werden kann.

\section{Bewertung der Domain-Driven Design Artefakte}
\label{sec:rating}
In diesem Abschnitt wird darauf eingegangen anhand welcher Bewertungskriterien die Artefakte bewertet werden. Ein Bewertungskriterium besteht aus einer Beschreibung und der Relevanz des jeweiligen Kriteriums. Die Relevanz spiegelt die Gewichtung des Bewertungskriteriums wieder.

\begin{table}[htbp] 
    \centering
    \begin{tabular}{l|ccccc}   \noalign{\hrule height 2pt}
        \textbf{Einstufungen}   & \texttt{INFO} & \texttt{MINOR}    & \texttt{MAJOR}    & \texttt{CRITICAL}     & \texttt{BLOCKER}  \\
        \textbf{Gewichtung}     & 0             & 1                 & 3                 & 5                     & 10                \\ \noalign{\hrule height 2pt}
    \end{tabular}
    \caption{Einstufungen der Relevanz eines Kriteriums}
    \label{tab:rating:criteria}
\end{table}

In der \autoref{tab:rating:criteria} sind die fünf Einstufungen der Relevanz aufgeführt. Jeder Einstufung ist eine Gewichtung zugeordnet. Zum Beispiel sind Kriterien die als \texttt{INFO} gekennzeichnet sind nicht relevant für die Bewertung. Diese Kriterien beschreiben häufig die Benennung von Komponenten. 

Als \texttt{MINOR} oder \texttt{MAJOR} eingestufte Kriterien sollten eingehalten werden, aber von ihrer Einhaltung hängt nicht die komplette Architektur ab. Dies betrifft zum Beispiel das Implementieren von vorgegebenen Methoden.

Kriterien welche hingegen als \texttt{CRITICAL} oder \texttt{BLOCKER} gekennzeichnet wurden, müssen zwingend erfüllt sein, da sonst Grundprinzipien vom Domain-Driven Design verletzt werden. Deshalb werden diese Kriterien besonders stark gewichtet.

\subsection{Bewertung von Modulen}
\label{sec:rating:modul}
Bei der Bewertung von Modulen muss zwischen drei Kategorien von Modulen unterschieden werden. Im Domain-Modul, dem wichtigsten Modul im Domain-Driven Design, sind alle Domain-Artefakte enthalten. Das zweitwichtigste Modul ist das Applikation-Modul. Dieses Modul beinhaltet nahezu die gesamte Geschäftslogik des Systems. Im Infrastruktur-Modul sind Schnittstellen implementiert, zum Beispiel für Datenbanken oder Benutzeroberflächen.

\begin{table}[htbp] 
    \centering
    \begin{tabular}{m{0.8\textwidth}c}   \noalign{\hrule height 2pt}
        \textbf{Kriterien}                                                  & \textbf{Relevanz} \\ \hline
        Modul: \texttt{domain}                                              & \texttt{MINOR}    \\ 
        Beinhaltet nur Domain-Artifakte                                     & \texttt{MAJOR}    \\ 
        Beinhaltet Aggregate Root                                           & \texttt{CRITICAL} \\ \noalign{\hrule height 2pt}
    \end{tabular}
    \caption{Kriterien zur Bewertung von Domain-Modulen}
    \label{tab:rating:modul:domain:criteria}
\end{table}

In der \autoref{tab:rating:modul:domain:criteria} sind die Kriterien von Domain-Modulen aufgelistet. Das erste Kriterium beschreibt, dass jedes Domain-Modul dem Modul \texttt{domain} untergeordnet sein sollte. Dieses Kriterium wurde als \texttt{MINOR} eingestuft, da es als Best Practice gilt, aber nicht zwingend notwendig ist.

Das zweite Kriterium betrachtet den Inhalt des Moduls, denn in einem Domain-Modul sollten nur Domain-Artefakte enthalten sein und keine Geschäftslogik oder Infrastrukturlogik. Da dieses Kriterium wichtiger ist, als das Erste, wurde es als \texttt{MAJOR} gekennzeichnet.

Das letzte Kriterium des Domain-Moduls, aus der \autoref{tab:rating:modul:domain:criteria}, ist gleichzeitig das wichtigste. Denn jedes Domain-Modul symbolisiert eine Domain und muss daher genau eine Aggregate Root beinhalten. Da dieses Kriterium für die korrekte Umsetzung von Domain-Driven Design notwendig ist, wurde es als \texttt{CRITICAL} eingestuft.

\begin{table}[htbp] 
    \centering
    \begin{tabular}{m{0.8\textwidth}c}   \noalign{\hrule height 2pt}
        \textbf{Kriterien}                                                  & \textbf{Relevanz} \\ \hline
        Modul: \texttt{application}                                         & \texttt{MINOR}    \\ 
        Beinhaltet nur Application-Artifakte                                & \texttt{MAJOR}    \\\noalign{\hrule height 2pt}
    \end{tabular}
    \caption{Kriterien zur Bewertung von Applikation-Modulen}
    \label{tab:rating:modul:applictaion:criteria}
\end{table}

\begin{table}[htbp] 
    \centering
    \begin{tabular}{m{0.8\textwidth}c}   \noalign{\hrule height 2pt}
        \textbf{Kriterien}                                                  & \textbf{Relevanz} \\ \hline
        Modul: \texttt{infrastructure}                                      & \texttt{MINOR}    \\
        Beinhaltet nur Infrastructure-Artifakte                             & \texttt{MAJOR}    \\ \noalign{\hrule height 2pt}
    \end{tabular}
    \caption{Kriterien zur Bewertung von Infrastruktur-Modulen}
    \label{tab:rating:modul:infrastructure:criteria}
\end{table}

Die Kriterien für Applikation- und Infrastruktur-Module, aus den Tabellen  \ref{tab:rating:modul:applictaion:criteria} und \ref{tab:rating:modul:infrastructure:criteria}, sind den ersten zwei Kriterien des Domain-Moduls sehr ähnlich.

\subsection{Bewertung von Domain Artefakten}
\label{sec:analyse:artifakt}
Der Schwerpunkt bei der Bewertung einer Softwarearchitektur auf Basis von Domain-Driven Design liegt darin, die einzelnen Domain Artefakte zu bewerten. Da die Domain Artefakte komplexer aufgebaut sind als Module, müssen sie auch anhand mehrerer Kriterien bewertet werden.

\subsubsection{Bewertungskriterien von Entities}
\label{sec:rating:artifakt:entity}
\begin{table}[H] 
    \centering
    \begin{tabular}{m{0.8\textwidth}c}  \noalign{\hrule height 2pt}
        \textbf{Kriterien}                                                  & \textbf{Relevanz} \\ \hline
        Modul: \texttt{domain.<domain>.model}                               & \texttt{MINOR}    \\ 
        Attribut-Typen: Entities oder Value Objects                         & \texttt{MAJOR}    \\
        Ein Attribut für die eigene Identität                               & \texttt{CRITICAL} \\
        Getter für jedes Attribut                                           & \texttt{MINOR}    \\ 
        Setter für jedes Attribut                                           & \texttt{MINOR}    \\
        Methoden \texttt{equals} und \texttt{hashCode}                      & \texttt{MAJOR}    \\ \noalign{\hrule height 2pt}
    \end{tabular}
    \caption{Kriterien zur Bewertung von Entities}
    \label{tab:rating:artifakt:entity:criteria}
\end{table}

Die \autoref{tab:rating:artifakt:entity:criteria} zeigt die Kriterien, welche von allen Entities eingehalten werden müssen. Das erste Kriterium beschreibt welchem Modul Entities zugeordnet sind. Da Entities zur Modellierung von Domains eingesetzt werden, sollten sie sich in dem Modul \texttt{domain.<domain>.model} befinden \cite{DDD:Vernon:2013}.

Die Attribute von Entities müssen Instanzen von anderen Entities oder Value Objects sein. Zum Beispiel werden zum Modellieren von Identitäten Value Objects verwendet \cite{DDD:Vernon:2013}. Da dieses Kriterium einen wichtigen Bestandteil von Entities einnimmt, wurde es als \texttt{MAJOR} eingestuft.

In der dritten Zeile der \autoref{tab:rating:artifakt:entity:criteria} ist das wichtigste Kriterium einer Entity aufgeführt. Dieses Kriterium sagt aus, dass jede Entity, wie bereits in \autoref{sec:basics:ddd:mdd:entity} beschrieben, eine Identität besitzen muss. Auf welche Art und Weise die Identität modelliert wurde, ist dabei für dieses Kriterium nicht relevant.  Da dieses Kriterium der hauptsächliche Unterschied zu Value Objects ist \cite{DDD:Vernon:2013}, wurde es als \texttt{CRITICAL} gekennzeichnet.

Als Letztes werden notwendige Methoden aufgeführt, welche implementiert sein müssen. Dazu zählen Getter und Setter \cite{DDD:Vernon:2013}. Ihre Existenz wird mit \texttt{MINOR} gewichtet, da sie benötigt werden um auf die Attribute zuzugreifen. Wichtiger für Entities ist die Existenz von den Methoden \texttt{equals} und \texttt{hashCode}. Die Implementierung dieser Methoden ermöglicht es Entities anhand ihrer Identität und nicht ihrer sonstigen Attribute zu unterscheiden \cite{DDD:Vernon:2013}. Da die Methoden \texttt{equals} und \texttt{hashCode} für die Funktionsweise von Entities wichtig sind, wurde dieses Kriterium als \texttt{MAJOR} eingestuft.

\subsubsection{Bewertungskriterien von Value Objects}
\label{sec:rating:artifakt:value_object}
\begin{table}[htbp] 
    \centering
    \begin{tabular}{m{0.8\textwidth}c}   \noalign{\hrule height 2pt}
        \textbf{Kriterien}                                                  & \textbf{Relevanz} \\ \hline
        Modul: \texttt{domain.<domain>.model}                               & \texttt{MINOR}    \\ 
        Attribut-Typen: Value Objects oder Standard Datentypen              & \texttt{MAJOR}    \\ 
        Kein Attribut für eigene Identität                                  & \texttt{BLOCKER}  \\
        Getter für jedes Attribut                                           & \texttt{MINOR}    \\ 
        Getter heißen so wie das zugehörige Attribut                        & \texttt{INFO}     \\ 
        Setter für jedes Attribut                                           & \texttt{MINOR}    \\
        Setter sind frei von Seiteneffekten                                 & \texttt{CRITICAL} \\ 
        Methoden \texttt{equals} und \texttt{hashCode}                      & \texttt{MAJOR}    \\ \noalign{\hrule height 2pt}
    \end{tabular}
    \caption{Kriterien zur Bewertung von Value Objects}
    \label{tab:rating:artifakt:value_object:criteria}
\end{table}

Die Kriterien von Value Objects aus \autoref{tab:rating:artifakt:value_object:criteria} sind den Kriterien der Entities ähnlich, unterscheiden sich aber in einigen Punkten. In der zweiten Zeile befindet sich eines der abweichenden Kriterien. Das Kriterium sagt aus, dass Value Objects nur Attribute von anderen Value Objects oder Java Standard Datentypen besitzen darf.

Das zweite Kriterium von Value Objects, welches sich grundlegend unterscheidet, steht in der dritten Zeile der \autoref{tab:rating:artifakt:value_object:criteria}. Wie bereits in \autoref{sec:basics:ddd:mdd:value_object} beschrieben, stellt die Existenz einer Identität eine Architekturverletzung dar. Deshalb wurde dieses Kriterium als \texttt{BLOCKER} eingestuft.

Auch ein Value Object sollte Getter und Setter für jedes Attribut besitzen. Allerdings sind dabei einzelne Kriterien zu beachten. Zur besseren Lesbarkeit wird empfohlen, Getter ohne den Präfix \texttt{get} zu benennen \cite{DDD:Vernon:2013}. Da die Verletzung dieses Kriteriums nicht gefährlich ist, wurde es als \texttt{INFO} gekennzeichnet.

Bei den Settern hingegen muss beachtet werden, dass sie keine Seiteneffekte haben \cite{DDD:Evans:2003}. Dieses Kriterium wird erfüllt, wenn die Methode als \texttt{private} gekennzeichnet wurde oder wenn die Methode eine neue Instanz von dem Value Object zurückgibt. In beiden Fällen ist gewährleistet, dass die Werte des Objects nicht verändert werden. Da die Unveränderbarkeit der Value Objects eine Grundvoraussetzung ist, wird dieses Kriterium als \texttt{CRITICAL} eingestuft.

\subsubsection{Bewertungskriterien von Aggregate Roots}
\label{sec:rating:artifakt:aggregate}
\begin{table}[htbp] 
    \centering
    \begin{tabular}{m{0.8\textwidth}c}  \noalign{\hrule height 2pt}
        \textbf{Kriterien}                                                  & \textbf{Relevanz} \\ \hline
        Modul: \texttt{domain.<domain>.model}                               & \texttt{MINOR}    \\
        Attribut-Typen: andere Entities oder Value Objects                  & \texttt{MAJOR}    \\ 
        Ein Attribut für die eigene Identität                               & \texttt{CRITICAL} \\ 
        Getter für jedes Attribut                                           & \texttt{MINOR}    \\ 
        Setter für jedes Attribut                                           & \texttt{MINOR}    \\ 
        Methoden \texttt{equals} und \texttt{hashCode}                      & \texttt{MAJOR}    \\ 
        Repository für die Aggregate Root existiert                         & \texttt{MAJOR}    \\
        Factory für die Aggregate Root existiert                            & \texttt{MAJOR}    \\
        Service für die Aggregate Root existiert                            & \texttt{MAJOR}    \\ \noalign{\hrule height 2pt}
    \end{tabular}
    \caption{Kriterien zur Bewertung von Aggregate Roots}
    \label{tab:rating:artifakt:aggregate:criteria}
\end{table}

Auch die Kriterien von Aggregate Roots, in der \autoref{tab:rating:artifakt:aggregate:criteria}, sind den Kriterien von Entities sehr ähnlich. Da Aggregate Roots, wie bereits in \autoref{sec:basics:ddd:mdd:aggregate} beschrieben, nur spezielle Entities sind, sind die ersten sechs Kriterien identisch.

Zusätzlich zu den ersten sechs Kriterien besitzt die Aggregate Root drei weitere. Da eine Aggregate Root ihre zugeordnete Domain repräsentiert, werden zur Verwaltung drei Komponenten benötigt. Nämlich ein Repository, eine Factory und mindestens ein Domain Service \cite{DDD:Vernon:2013}. Diese drei Kriterien werden, aufgrund ihrer Relevanz für die Architektur, als \texttt{MAJOR} eingestuft.

\subsubsection{Bewertungskriterien von Factories}
\label{sec:rating:artifakt:factory}
\begin{table}[htbp] 
    \centering
    \begin{tabular}{m{0.8\textwidth}c}   \noalign{\hrule height 2pt}
        \textbf{Kriterien}                                                  & \textbf{Relevanz} \\ \hline
        Interface-Namenssuffix: \glqq Factory\grqq{}                        & \texttt{INFO}     \\ 
        Klassen-Namenssuffix: \glqq FactoryImpl\grqq{}                      & \texttt{INFO}     \\ 
        Interface-Modul: \texttt{domain.<domain>.model}                     & \texttt{MINOR}    \\ 
        Klassen-Modul: \texttt{domain.<domain>.model.impl}                  & \texttt{MINOR}    \\
        Factory Klasse implementiert Factory Interface                      & \texttt{MINOR}    \\
        Enthält eine Instanz eines Repositories	                            & \texttt{MAJOR}    \\
        Methode zum Erzeugen (\texttt{create})                              & \texttt{MAJOR}    \\ \noalign{\hrule height 2pt}
    \end{tabular}
    \caption{Kriterien zur Bewertung von Factories}
    \label{tab:rating:artifakt:factory:criteria}
\end{table}

Bei der Bewertung von Factories muss zunächst zwischen Factory Interfaces und Factory Klassen unterschieden werden. Denn es gibt für sie unterschiedliche Namenskonventionen und sie sollten in unterschiedlichen Modulen untergebracht sein. Die Namenskonventionen in den zwei ersten Zeilen der \autoref{tab:rating:artifakt:factory:criteria} sind als \texttt{INFO} gekennzeichnet, da es sich um eine Java-Konvention handelt. Klassen, welche ein Interface implementieren, sollten mit dem Suffix \glqq Impl\grqq{} benannt werden \cite{DDD:Vernon:2013}.

Die Factory Interfaces und Factory Klassen unterscheiden sich aber nicht nur bei ihrer Namenskonvention, sondern auch bei den Modulen denen sie zugeordnet sind. Während die Interfaces Bestandteile des Moduls \texttt{domain.<domain>.model} sind, sollten die Klassen in dem untergeordneten Modul \texttt{impl} zu finden sein \cite{DDD:Vernon:2013}. Ähnlich wie bei den vorherigen Artefakten ist die Zuordnung zu Modulen als \texttt{MINOR} eingestuft.

Da eine Factory, wie im \autoref{sec:basics:ddd:mdd:factory} beschrieben, für die Erzeugung von Entities zuständig ist, benötigt sie eine Instanz des dazugehörigen Repositories, um die neue Entity zu persistieren. Das Erzeugen der Entity sollte, wie in der letzten Zeile der \autoref{tab:rating:artifakt:factory:criteria} beschrieben, mit der Methode \texttt{create} geschehen. Die beiden letzten Kriterien werden mit einer Relevanz von \texttt{MAJOR} bewertet.

\subsubsection{Bewertungskriterien von Repositories}
\label{sec:rating:artifakt:repository}
\begin{table}[H] 
    \centering
    \begin{tabular}{m{0.8\textwidth}c}   \noalign{\hrule height 2pt}
        \textbf{Kriterien}                                                  & \textbf{Relevanz} \\ \hline
        Interface-Namenssuffix: \glqq Repository\grqq{}                     & \texttt{INFO}     \\ 
        Klassen-Namenssuffix: \glqq RepositoryImpl\grqq{}                   & \texttt{INFO}     \\ 
        Interface-Modul: \texttt{domain.<domain>.model}                     & \texttt{MINOR}    \\ 
        Klassen-Modul: \texttt{domain.<domain>.model.impl}                  & \texttt{MINOR}    \\ 
        Repository Klasse implementiert Repository Interface                & \texttt{MINOR}    \\ 
        Methode zum Erzeugen einer neuen Identität (\texttt{nextIdentity})  & \texttt{MAJOR}    \\ 
        Methode zum Finden (\texttt{findBy/get})                            & \texttt{MAJOR}    \\ 
        Methode zum Speichern (\texttt{save/add/insert/put})                & \texttt{MAJOR}    \\ 
        Methode zum Löschen (\texttt{delete/remove})                        & \texttt{MAJOR}    \\ 
        Methode zum Überprüfen der Existenz (\texttt{contains/exists})      & \texttt{MINOR}    \\ 
        Methode zum Aktualisieren (\texttt{update})                         & \texttt{MINOR}    \\ \noalign{\hrule height 2pt}
    \end{tabular}
    \caption{Kriterien zur Bewertung von Repositories}
    \label{tab:rating:artifakt:repository:criteria}
\end{table}

Die ersten fünf Kriterien von Repositories, in der \autoref{tab:rating:artifakt:repository:criteria} sind gleich aufgebaut wie im vorherigen \autoref{sec:rating:artifakt:factory}.

Bei den notwendigen Methoden unterscheiden sich allerdings die Bewertungskriterien der Repositories und Factories. Die erforderlichen Methoden wurden in zwei Kategorien eingeteilt.

Die erste Kategorie enthält Methoden, welche unverzichtbar für ein Repository sind. Zu den Methoden der ersten Kategorie gehören Methoden zum Erzeugen einer neuen Identität sowie zum Finden, Speichern und Löschen einer Entity. Die Methoden dieser Kategorie wurden als \texttt{MAJOR} eingestuft.

In der zweiten Kategorie sind Methoden aufgelistet, welche nützlich sind aber nicht so relevant wie die Methoden aus der ersten Kategorie. Dazu gehören Methoden zum Aktualisieren und Überprüfen der Existenz einer Entity. Aufgrund ihrer geringeren Relevanz wurden diese Methoden als \texttt{MINOR} bewertet.

\subsubsection{Bewertungskriterien von Domain Events}
\label{sec:rating:artifakt:event}
\begin{table}[htbp]
    \centering
    \begin{tabular}{m{0.8\textwidth}c}   \noalign{\hrule height 2pt}
        \textbf{Kriterien}                                                  & \textbf{Relevanz} \\ \hline
        Modul: \texttt{domain.<domain>.model}                               & \texttt{MINOR}    \\ 
        Attribut für Zeitstempel                                            & \texttt{MAJOR}    \\ 
        Attribut für die ID einer Entity                                    & \texttt{MAJOR}    \\ 
        Getter für jedes Attribut                                           & \texttt{MINOR}    \\ 
        Setter sind frei von Seiteneffekten                                 & \texttt{CRITICAL} \\ \noalign{\hrule height 2pt}
    \end{tabular}
    \caption{Kriterien zur Bewertung von Domain Events}
    \label{tab:rating:artifakt:event:criteria}
\end{table}

Das erste Kriterium von Domain Events, aus der \autoref{tab:rating:artifakt:event:criteria}, verhält sich analog zu den bereits behandelten Komponenten. 

Wie bereits im \autoref{sec:basics:ddd:mdd:event} beschrieben wurde, muss ein Domain Event zwei Attribute besitzen. Ein Attribut welches den Zeitpunkt des Auftretens des Events dokumentiert. Sowie ein Attribut mit der Identität der beteiligten Entity. Die Relevanz beider Kriterien ist \texttt{MAJOR}.

Das wichtigste Bewertungskriterium ist die Unveränderlichkeit von Domain Events. Dieses Bewertungskriterium wurde wie bei der Bewertung von Value Objects anhand von seiteneffektfreien Settern realisiert und auch als \texttt{CRITICAL} eingestuft.

\subsubsection{Bewertungskriterien von Services}
\label{sec:rating:artifakt:service}
\begin{table}[htbp] 
    \centering
    \begin{tabular}{m{0.8\textwidth}c}   \noalign{\hrule height 2pt}
        \textbf{Kriterien}                                                  & \textbf{Relevanz} \\ \hline
        Application Service Name beinhaltet \glqq Application\grqq{}        & \texttt{INFO}     \\ 
        Application Service Modul: \texttt{application}                     & \texttt{MINOR}    \\ 
        Domain Service Modul: \texttt{application.<domain>}                 & \texttt{MINOR}    \\ \noalign{\hrule height 2pt}
    \end{tabular}
    \caption{Kriterien zur Bewertung von Services}
    \label{tab:rating:artifakt:service:criteria}
\end{table}

Bei der Bewertung von Services muss zwischen zwei Services unterschieden werden, die Application und Domain Services. 

Die Application Services werden anhand von zwei Kriterien bewertet, siehe \autoref{tab:rating:artifakt:service:criteria}. Der Name des Application Services sollte das Wort \glqq Application\grqq{} beinhalten. Dieses Kriterium ist mit \texttt{INFO} gewichtet. Außerdem muss der Application Service dem Modul \texttt{application} zugeordnet sein. Die Zuordnung zu dem speziellen Modul ist als \texttt{MINOR} eingestuft.

Die Domain Services erfüllen alle Kriterien, wenn sie in dem Modul \texttt{appli\-cation.\-<domain>} enthalten sind. Auch dieses Kriterium besitzt eine Relevanz von \texttt{MINOR}.

\subsection{Dokumentation der nicht erfüllten Kriterien}
\label{sec:rating:issue}
Damit die Bewertungen der Domain-Driven Design Baustein zu jedem Zeitpunkt nachvollzogen werden kann, werden die nicht erfüllten Kriterien mit einer Beschreibung des Problems zurückgegeben.

\begin{lstlisting}[caption={Ausschnitt der Bewertung eines Artefakts},captionpos=b,label=lst:rating:issue:output, language=my_json]
{
  "DDD": "ENTITY",
  "fitness": 55.56,
  "domain": "owner",
  "name": "PetType",
  "issues": [
    "[MAJOR] The Entity 'BaseEntity' does not contains all needed methods (equals/hashCode).",
    ...
  ]
}
\end{lstlisting}

\autoref{lst:rating:issue:output} zeigt einen Ausschnitt des Rückgabewertes eines bewerteten Artefakts. Daran kann deutlich erkannt werden, welche Kriterien nicht eingehalten wurden und woran es gelegen hat.

\section{Bewertung anhand von verschiedenen Metriken}
\label{sec:analyse:metric}

\subsection{Object-Oriented Design Metriken}
\label{sec:analyse:metric:ood}
In diesem Abschnitt werden verschiedene Metriken zur Bewertung von Ob\-ject-Oriented Design behandelt. Die verwendeten Metriken stammen aus dem Artikel \glqq OO Design Quality Metrics\grqq{} \cite{Metric:Martin:1994}. Die Metriken beschreiben die Zustände der einzelnen Module eines Systems. Dabei werden die Abstraktheit sowie die Stabilität der Module gemessen.

\begin{equation}
    \text{Abstractness} = \frac{\text{Anzahl abstrakter Artefakte}}{\text{Gesamt Anzahl aller Artefakte}} \label{align:analyse:metric:ood:abstractness}
\end{equation}

Die Abstraktheit eines Moduls ist das Verhältnis von abstrakten Artefakten und allen anderen Artefakten \cite{Metric:Martin:1994}. Sie kann durch die \autoref{align:analyse:metric:ood:abstractness} berechnet werden. Der Wertebereich der Abstraktheit beträgt [0; 1].

Um die Stabilität eines Moduls zu bestimmen, müssen die Abhängigkeiten des Moduls betrachtet werden. Dabei muss zwischen Afferent und Efferent Couplings unterschieden werden. Unter Afferent Couplings versteht man die Anzahl der Artefakte außerhalb dieses Moduls, welche von diesem Modul abhängig sind \cite{Metric:Martin:1994}. Efferent Couplings ist das Gegenteil von Afferent Couplings. Efferent Couplings ist die Anzahl der Klassen innerhalb dieses Moduls, welche von einem anderem Modul abhängen.

\begin{equation}
    \text{Instability} = \frac{\text{Efferent Couplings}}{\text{Afferent Couplings} + \text{Efferent Couplings}} \label{align:analyse:metric:ood:instability}
\end{equation}

Ein Modul gilt als instabil, wenn es mehr Efferent als Afferent Couplings besitzt \cite{Metric:Martin:1994}. Anhand der \autoref{align:analyse:metric:ood:instability} kann die Instabiliät berechnet werden. Auch hier ist der Wertebereich [0; 1].

\begin{figure}[H]
    \centering
    \includegraphics[width=0.45\textwidth]{gfx/metric-temp-ood.pdf}
    \caption{Zusammenhang zwischen den Object-Oriented Design Metriken \cite{Metric:Martin:1994}}
    \label{fig:analyse:metric:ood}
\end{figure}

Laut Martin \cite{Metric:Martin:1994} sollte das Verhältnis zwischen der Abstraktheit und der Instabilität eines Moduls ausgeglichen sein. In der \autoref{fig:analyse:metric:ood} ist dieses ausgeglichene Verhältnis als Diagonale dargestellt. Diese Diagonale wird auch Main Sequence genannt. In einem guten Object-Oriented Design sollten alle Module auf der Main Sequence liegen.

\begin{equation}
    \text{Distance} = | \text{Abstractness} + \text{Instability} - 1 | \label{align:analyse:metric:ood:distance}
\end{equation}

Um die Abweichung von der Main Sequence zu ermitteln, kann die Distanz zu der Main Sequence mit der \autoref{align:analyse:metric:ood:distance} ermittelt werden. Da ein Modul im besten Fall keine Abweichung von der Main Sequence haben sollte, ist der bestmögliche Wert für die Distanz \texttt{0}.

\begin{lstlisting}[caption={Ausschnitt der Object-Oriented Design Bewertung eines Systems},captionpos=b,label=lst:analyse:metric:ood:output, language=my_json]
"OOD": {
    "distance": {
        "avg": 0.39,
        "min": 0.17,
        "median": 0.2,
        "max": 1,
        "standard deviation": 0.41
    },
    "module": {
        "BOOT-INF.classes.org.springframework.samples.petclinic.visit": {
            "distance": 0.17,
            "instability": 0.33,
            "abstractness": 0.5
        }, 
        ...
    }
}
\end{lstlisting}

Die in diesem Abschnitt beschriebenen Metriken werden für jedes Modul berechnet und in dem Format aus \autoref{lst:analyse:metric:ood:output} zurückgegeben.

\subsection{Domain-Driven Design Metrik}
\label{sec:analyse:metric:ddd}
Damit eine Aussage über den Zustand des Gesamtsystems getroffen werden kann, ist es notwendig eine Metrik zu definieren. In dieser Metrik sollten alle Kriterien und ihre Relevanz einbezogen werden, damit sie aussagekräftig ist.

\begin{equation}
    \text{Totale Kriterien} = \sum \limits_{k}^\text{Kriterien} Relevanz(k) \label{align:analyse:metric:ddd:total}
\end{equation}

Im ersten Schritt wird, anhand der \autoref{align:analyse:metric:ddd:total}, die Wertigkeit aller Kriterien berechnet. Dafür werden die Gewichtungen aller benötigten Kriterien summiert. Dadurch wird die maximal mögliche Bewertung des Systems erlangt.

\begin{equation}
    \text{Erfüllte Kriterien} = \sum \limits_{k}^\text{Kriterien} Relevanz(k)\text{ falls }k\text{ erfüllt} \label{align:analyse:metric:ddd:fulfilled}
\end{equation}

Als Nächstes wird die \autoref{align:analyse:metric:ddd:fulfilled} angewandt, um die Summe der Gewichtungen aller erfüllten Kriterien zu erhalten. Dieser Wert symbolisiert den tatsächlichen Zustand des Systems.

\begin{equation}
    \text{Metrik} = \frac{\text{Erfüllte Kriterien} \cdot 100}{\text{Totale Kriterien}} \label{align:analyse:metric:ddd}
\end{equation}

Zur Berechnung der Gesamtbewertung werden die vorherigen Ergebnisse in die \autoref{align:analyse:metric:ddd} eingesetzt. Das Ergebnis ist eine Metrik, welche die prozentuale Erfüllung aller benötigten Kriterien, unter Einbeziehung ihrer Relevanz, aussagt.

\begin{table}[htbp] 
    \centering
    \begin{tabular}{cll}   \noalign{\hrule height 2pt}
        \textbf{Note}   & \textbf{Beschreibung} & \textbf{Wertebereich}                 \\ \hline
        \texttt{A}      & sehr gut              & $\text{Metrik } \geq 95.0$            \\ 
        \texttt{B}      & gut                   & $95.0 > \text{ Metrik } \geq 90.0$    \\ 
        \texttt{C}      & befriedigend          & $90.0 > \text{ Metrik } \geq 80.0$    \\ 
        \texttt{D}      & ausreichend           & $80.0 > \text{ Metrik } \geq 50.0$    \\ 
        \texttt{E}      & mangelhaft            & $50.0 > \text{ Metrik } \geq 20.0$    \\ 
        \texttt{F}      & ungenügend            & $20.0 > \text{ Metrik } \geq 0.0$     \\ \noalign{\hrule height 2pt}
    \end{tabular}
    \caption{Benotung der Domain-Driven Design Metrik}
    \label{tab:analyse:metric:ddd}
\end{table}

Um die Metrik aus der \autoref{align:analyse:metric:ddd} besser einzuordnen, wird dem System anhand der \autoref{tab:analyse:metric:ddd} eine Note gegeben. Die Grenzwerte der einzelnen Noten sind von SonarQube inspiriert und orientieren sich an dem Maintainability Rating \cite{Metric:SonarSource:2019}. Es wurde diese Metrik ausgewählt da sie einen ähnlichen Sachverhalt beschreibt. 

\begin{lstlisting}[caption={Ausschnitt der Domain-Driven Design Bewertung eines Systems},captionpos=b,label=lst:analyse:metric:ddd:output, language=my_json]
"DDD": {
    "artifact": {
        "#APPLICATION_SERVICE": 1,
        "#MODULE": 5,
        "#REPOSITORY": 4,
        "#INFRASTRUCTUR": 8,
        "#SERVICE": 2,
        "#ENTITY": 6,
        "#AGGREGATE_ROOT": 2
    },
    "metric": {
        "score": "E",
        "statistic": {
            "avg": 30.09,
            "min": 0,
            "median": 40,
            "max": 80,
            "standard deviation": 27.22
        },
        "fitness": 46.21,
        "#Issues": 76
    },
    ...
}
\end{lstlisting}

Anschließend wird die Gesamtbewertung in dem Format aus \autoref{lst:analyse:metric:ddd:output} mit zusätzlichen Informationen zurückgegeben.