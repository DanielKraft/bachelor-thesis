\chapter{Generierung eines Architekturvorschlags auf Basis von Domain-Driven Design}
\label{ch:suggestion}
In diesem Kapitel wird die automatische Generierung eines Verbesserungsvorschlags erläutert. Zu Beginn wird auf die Umwandlungskriterien eingegangen und im Anschluss wird die Implementierung des Umwandlungsalgorithmus beschrieben.

\section{Beschreibung der Umwandlungskriterien}
\label{sec:suggestion:criteria}
Der Umwandlungsalgorithmus hat das Ziel die Architektur eines Systems auf Basis von Domain-Driven Design zu verbessern. Im vorherigen Kapitel \ref{sec:analyse:metric:ddd} wurde eine Metrik entwickelt welche den Zustand eines Systems bewertet. Daher werden die Bewertungskriterien für diese Metrik aus dem Abschnitt \ref{sec:analyse:rating} auch als Umwandlungskriterien für den Umwandlungsalgorithmus verwendet. Durch die Nutzung der gleichen Kriterien kann die Metrik zur späteren Bewertung des Umwandlungsalgorithmus verwendet werden.

\section{Implementierung des Umwandlungsalgorithmus}
\label{sec:suggestion:impl}
Der Umwandlungsalgorithmus besteht aus drei Phasen. In der ersten Phase wird die Module initialisiert. Anschließend werden die vorhandenen Artefakte den richtigen Module zugeordnet. In der letzten und wichtigsten Phase werden alle Artefakte, auf Basis der Umwandlungskriterien, überarbeitet.

\subsection{Initialisieren der Module}
\label{sec:suggestion:impl:init}
Bei dem Initialisieren der neuen Module wird auf die Struktur des ursprünglichen Systems keine Rücksicht genommen. Als einzige Information werden die Namen der Aggregate Roots benötigt, um die Domain Module zu erzeugen.

\begin{figure}[ht]
    \centering
    \includegraphics[width=0.5\textwidth]{gfx/module-init.pdf}
    \caption{Initiale Module}
    \label{fig:suggestion:impl:module}
\end{figure}

In der Abbildung \ref{fig:suggestion:impl:module} ist die initiale Struktur der Module zu erkennen. Es wird für jede Schicht der Layered Architecture, aus Abschnitt \ref{sec:basics:ddd:mdd:layer}, ein Module erzeugt. In den Module \texttt{application} und \texttt{domain} werden zusätzlich Module für die einzelnen Domains erstellt.


\subsection{Zuordnen der Artefakte}
\label{sec:suggestion:impl:assign}
Nachdem die Struktur der Module initialisiert wurde, können die Artefakte des ursprünglichen Systems dem richtigen Module zugeordnet werden. Dabei werden jegliche Infrastruktur Artefakte dem Module \texttt{infrastructure} zugeordnet, siehe Abbildung \ref{fig:anhang:petclinic:new:infrastructure} im Anhang. Service Artefakte werden dem zugehörigen Domain Module im Module \texttt{application} zugeteilt. Die Abbildung \ref{fig:anhang:petclinic:new:application} aus dem Anhang zeigt eine solche Zuordnung.

Die Zuordnung von Aggregate Roots, Entities, Value Objects und Domain Events wird aufgrund ihrer zugehörigen Domain entschieden. Dabei ist es irrelevant ob die Artefakte zuvor gemeinsam in einem Module waren. Es können durch diesen Prozess jederzeit alte Module zusammengefasst oder zerteilt werden. Dieser Prozess kann durch das Beispiel im Anhang \ref{sec:anhang:beispiel:petclinic} verdeutlicht werden. In der Abbildung \ref{fig:anhang:petclinic:old} befindet sich das Domain Event \texttt{Visit} in einem eigenem Module und wird gleichzeitig von der Entity \texttt{Pet} als Attribut verwendet. Nachdem das System verbessert wurde befinden sich beide Artefakte im selbem Module, wie in Abbildung \ref{fig:anhang:petclinic:new:domain:owner} zu sehen ist.

Bei Repositories und Factories muss zwischen Interfaces und Klassen unterschieden werden. Inferfaces werden wie in Abbildung \ref{fig:anhang:petclinic:new:domain:vet} dem Domain Module zugeordnet. Klassen hingegen sind dem untergeordneten Module \texttt{impl} zugehörig.

In manchen Fällen können Artefakte keinem Domain Module eindeutig zugeordnet werden. In der Abbildung \ref{fig:anhang:petclinic:old} befinden sich in dem Module \texttt{petclinic.model} drei Klassen von denen mehrere Klassen aus verschiedenen Domains abhängig sind, daher wurden diese Klassen von dem Umwandlungsalgorithmus dem separaten Module \texttt{petclinic.domain.model} in Abbildung \ref{fig:anhang:petclinic:new:domain:model} zugeordnet.

\subsection{Überarbeitung der Artefakte}
\label{sec:suggestion:impl:refactor}
Die Überarbeitung der Artefakte wird für jeden Artefakttype separat durchgeführt. Der Aufgabenbereich der letzten Phase reicht von der Überarbeitung von Attributen sowie Methoden bis zum Erstellen von neuen Artefakten.

\begin{figure}[ht]
    \centering
    \subfloat[Subfigure 1][ursprüngliches \\ Artefakt]{
        \includegraphics[width=0.25\textwidth]{gfx/example/adm/uml-adm-IssueRepository-old.pdf}
        \label{fig:suggestion:impl:refactor:issuerepository:old}}
    \subfloat[Subfigure 2][verbessertes \\ Artefakt]{
        \includegraphics[width=0.25\textwidth]{gfx/example/adm/uml-adm-IssueRepository-new.pdf}
        \label{fig:suggestion:impl:refactor:issuerepository:new}}
    \caption{Refactoring eines Repository Interfaces}
    \label{fig:suggestion:impl:refactor:issuerepository}
\end{figure}

Am bessten lässt sich das Überarbeiten von Methoden eines Artefakts an dem Beispiel aus der Abbildung \ref{fig:suggestion:impl:refactor:issuerepository} zeigen. Die beiden Artefakte sind Ausschnitte aus den Abbildungen im Abschnitt \ref{sec:anhang:beispiel:adm} des Anhangs. Die Abbildung \ref{fig:suggestion:impl:refactor:issuerepository:old} zeigt die ursprüngliche Definition des Artefakts \texttt{IssueRepository}. Ursprünglich besaß dieses Artefakt nur zwei Methoden. Durch den Umwandlungsalgorithmus wurden dem Artefakt, aus der Abbildung \ref{fig:suggestion:impl:refactor:issuerepository:new}, sechs weitere Methoden hinzugefügt welche als Kriterien in der Tabelle \ref{tab:analyse:rating:artifakt:repository:criteria} aufgeführt sind. 

In speziellen Fällen kann es von Vorteil sein, dass eine Entity zu einem Value Object umgewandelt werden sollte. Dies bietet sich an wenn die Entity abgesehen von ihrer Identität nur ein Attribut enthält. 

\begin{figure}[ht]
    \centering
    \subfloat[Subfigure 1][ursprüngliches \\ Artefakt]{
        \includegraphics[width=0.25\textwidth]{gfx/example/ddd/uml-ddd-IssueComment-old.pdf}
        \label{fig:suggestion:impl:refactor:issuecomment:old}}
    \subfloat[Subfigure 2][verbessertes \\ Artefakt]{
        \includegraphics[width=0.25\textwidth]{gfx/example/ddd/uml-ddd-IssueComment-new.pdf}
        \label{fig:suggestion:impl:refactor:issuecomment:new}}
    \caption{Refactoring einer Entity zu einem Value Object}
    \label{fig:suggestion:impl:refactor:issuecomment}
\end{figure}

In der Abbildung \ref{fig:suggestion:impl:refactor:issuecomment} ist ein solches Beispiel aufgeführt. Das Beispiel stammt aus dem Abschnitt \ref{sec:anhang:beispiel:ddd} im Anhang. Die Entity \texttt{IssueComment} aus der Abbildung \ref{fig:suggestion:impl:refactor:issuecomment:old} verfügt nur über eine Identität und einem weiteren Attribut, daher ist es nicht notwendig dieses Artefakt als Entity zu modellieren. Die Abbildung \ref{fig:suggestion:impl:refactor:issuecomment:new} zeigt das resultierende Value Object. Es verfügt nur noch über ein Attribut und auch die Methoden wurden an die Kriterien für Value Objects aus der Tabelle \ref{tab:analyse:rating:artifakt:value_object:criteria} angepasst. 