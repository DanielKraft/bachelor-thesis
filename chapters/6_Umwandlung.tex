\chapter{Generierung eines Architekturvorschlags}
\label{ch:suggestion}
In diesem Kapitel wird die automatische Generierung eines Verbesserungsvorschlags erläutert. Zu Beginn wird auf die Umwandlungskriterien eingegangen und im Anschluss die Implementierung des Umwandlungsalgorithmus beschrieben.

\section{Beschreibung der Umwandlungskriterien}
\label{sec:suggestion:criteria}
Der Umwandlungsalgorithmus hat das Ziel die Architektur eines Systems auf Basis von Domain-Driven Design zu verbessern. Im vorherigen Kapitel \ref{sec:analyse:metric:ddd} wurde eine Metrik entwickelt, welche zum Bewerten des Zustands eines Systems verwendet werden kann. Daher werden die Bewertungskriterien aus dem Abschnitt \ref{sec:rating} auch als Umwandlungskriterien für den Umwandlungsalgorithmus verwendet. Durch die Nutzung der gleichen Kriterien kann die Metrik zur späteren Bewertung des Umwandlungsalgorithmus verwendet werden.

\section{Implementierung des Umwandlungsalgorithmus}
\label{sec:suggestion:impl}
Der Umwandlungsalgorithmus besteht aus vier Phasen. In der ersten Phase werden die Module initialisiert. Anschließend werden die vorhandenen Artefakte den richtigen Modulen zugeordnet. In der dritten und wichtigsten Phase werden alle Artefakte, auf Basis der Umwandlungskriterien, überarbeitet. Am Ende wird die überarbeitete Architektur aufgeräumt.

\subsection{Initialisieren der Module}
\label{sec:suggestion:impl:init}
Bei dem Initialisieren der neuen Module wird auf die Struktur des ursprünglichen Systems keine Rücksicht genommen. Als einzige Information werden die Namen der Aggregate Roots benötigt, um die Domain Module zu benennen.

\begin{figure}[ht]
    \centering
    \includegraphics[width=0.75\textwidth]{gfx/module-init.pdf}
    \caption{Initiale Struktur der Module}
    \label{fig:suggestion:impl:module}
\end{figure}

In der Abbildung \ref{fig:suggestion:impl:module} ist die initiale Struktur der Module zu erkennen. Es wird für jede Schicht der Layered Architecture, aus dem Abschnitt \ref{sec:basics:ddd:mdd:layer}, ein Modul erzeugt. In den Module \texttt{application} und \texttt{domain} werden zusätzlich Module für die einzelnen Domains erstellt.

\subsection{Zuordnen der Artefakte}
\label{sec:suggestion:impl:assign}
Nachdem die Struktur der Module initialisiert wurde, können die Artefakte des ursprünglichen Systems dem richtigen Modul zugeordnet werden. Dabei werden jegliche Infrastruktur Artefakte dem Module \texttt{infrastructure} zugeordnet, siehe Abbildung \ref{fig:anhang:petclinic:new:infrastructure} im Anhang. Service Artefakte werden dem zugehörigen Domain Module im Module \texttt{application} zugeteilt. Die Abbildung \ref{fig:anhang:petclinic:new:application} aus dem Anhang zeigt eine solche Zuordnung.

Die Zuordnung von Aggregate Roots, Entities, Value Objects und Domain Events wird aufgrund ihrer zugehörigen Domain entschieden. Dabei ist es irrelevant, ob die Artefakte zuvor gemeinsam in einem Modul waren. Es können durch diesen Prozess jederzeit alte Module zusammengefasst oder aufgeteilt werden. 

\begin{lstlisting}[caption={Finden der passenden Domain}, captionpos=b, label=lst:suggestion:impl:assign, language=my_java]
private String getDomainOf(Artifact artifact) {
  for (Class root : refactorData.getRoots()) {
    if (isRootOf(root, artifact)) {
      return root.getLowerName();
    }
  }
  return null;
}

private boolean isRootOf(Class root, Artifact artifact) {
  return artifact.getLowerName().contains(root.getLowerName())
    || artifact.getLowerName().contains(root.getDomain())
    || artifact.getPath().contains("." + root.getDomain() + ".")
    || (artifact.getDomain() != null
        && artifact.getDomain().equalsIgnoreCase(root.getDomain()));
}
\end{lstlisting}

Die Methoden in Listing \ref{lst:suggestion:impl:assign} zeigen wie einem Artefakt eine Domain zugeordnet wird. Die Methode \texttt{getDomainOf} durchläuft alle Aggregate Roots und überprüft mit der zweiten Methode \texttt{isRootOf}, ob das Artefakt zur selben Domain gehört. Damit ein Artefakt einer Domain zugeordnet werden kann, muss mindestens ein Merkmal aus den folgende vier erfüllt sein. Die ersten beiden Merkmale aus der 11. und 12. Zeile betreffen den Namen des Artefakts. Der Name des Artefakts sollte den Namen oder die Domain der Aggregate Root enthalten. Das dritte Merkmal steht in der 13. Zeile und analysiert den Pfad des Artefakts. Das Artefakt gehört demzufolge zur gleichen Domain wie die Aggregate Root, wenn der Pfad des Artefakts den Domainnamen der Aggregate Root enthält. Das letzte Merkmal ist erfüllt, wenn das Artefakt und die Aggregate Root im ursprünglichen System der gleichen Domain zugeordnet waren.

Dieser Prozess kann durch das Beispiel im Anhang \ref{sec:anhang:beispiel:petclinic} verdeutlicht werden. In der Abbildung \ref{fig:anhang:petclinic:old} befindet sich das Domain Event \texttt{Visit} in einem eigenen Modul und wird gleichzeitig von der Entity \texttt{Pet} als Attribut verwendet. Nachdem das System überarbeitet wurde, befinden sich beide Artefakte im selbem Module, wie in Abbildung \ref{fig:anhang:petclinic:new:domain:owner} zu sehen ist.

Bei Repositories und Factories muss zwischen Interfaces und Klassen unterschieden werden. Inferfaces werden wie in Abbildung \ref{fig:anhang:petclinic:new:domain:vet} dem Domain Module zugeordnet. Klassen hingegen sind dem untergeordneten Module \texttt{impl} zugehörig.

In manchen Fällen können Artefakte keinem Domain Module eindeutig zugeordnet werden. In der Abbildung \ref{fig:anhang:petclinic:old} befinden sich in dem Module \texttt{petclinic.model} drei Klassen von denen mehrere Klassen aus verschiedenen Domains abhängig sind, daher wurden diese Klassen von dem Umwandlungsalgorithmus dem separaten Module \texttt{petclinic.domain.model} in Abbildung \ref{fig:anhang:petclinic:new:domain:model} zugeordnet.

\subsection{Überarbeitung der Artefakte}
\label{sec:suggestion:impl:refactor}
Die Überarbeitung der Artefakte wird für jeden Artefakttyp separat durchgeführt. Der Aufgabenbereich dieser Phase reicht von der Überarbeitung von Attributen und Methoden bis zum Erstellen von neuen Artefakten.

\subsubsection{Überarbeiten der Interne Struktur von Artefakten}
\label{sec:suggestion:impl:refactor:update}

\begin{figure}[ht]
    \centering
    \subfloat[Subfigure 1][ursprüngliches \\ Artefakt]{
        \includegraphics[width=0.2\textwidth]{gfx/example/adm/uml-adm-IssueRepository-old.pdf}
        \label{fig:suggestion:impl:refactor:update:issuerepository:old}}
    \qquad \qquad
    \subfloat[Subfigure 2][verbessertes \\ Artefakt]{
        \includegraphics[width=0.2\textwidth]{gfx/example/adm/uml-adm-IssueRepository-new.pdf}
        \label{fig:suggestion:impl:refactor:update:issuerepository:new}}
    \caption{Refactoring eines Repository Interfaces}
    \label{fig:suggestion:impl:refactor:update:issuerepository}
\end{figure}

Am besten lässt sich das Überarbeiten von Methoden eines Artefakts an dem Beispiel aus der Abbildung \ref{fig:suggestion:impl:refactor:update:issuerepository} zeigen. Die beiden Artefakte sind Ausschnitte aus den Abbildungen im Abschnitt \ref{sec:anhang:beispiel:adm} des Anhangs. Die Abbildung \ref{fig:suggestion:impl:refactor:update:issuerepository:old} zeigt die ursprüngliche Definition des Artefakts \texttt{IssueRepository}. Ursprünglich besaß dieses Artefakt nur zwei Methoden. Durch den Umwandlungsalgorithmus wurden dem Artefakt, aus der Abbildung \ref{fig:suggestion:impl:refactor:update:issuerepository:new}, sechs weitere Methoden hinzugefügt welche als Kriterien in der Tabelle \ref{tab:rating:artifakt:repository:criteria} aufgeführt sind.

\subsubsection{Verändern des Artefakttypes}
\label{sec:suggestion:impl:refactor:change}
In speziellen Fällen kann es ein Vorteil sein, dass eine Entity zu einem Value Object umgewandelt wird. Dies bietet sich an, wenn die Entity ein Attribut enthält, welches den gleichen Namen besitzt wie die Entity.

\begin{lstlisting}[caption={Überprüfung einer Entity}, captionpos=b, label=lst:suggestion:impl:refactor:change, language=my_java]
private boolean isValueObject(Class artifact) {
  if (artifact.getSuperClass() == null) {
    for (Field field : artifact.getFields()) {
      if (artifact.getName().toLowerCase().contains(field.getName())
            && field.getType().startsWith("java.lang.")) {
        return true;
      }
    }
  }
  return false;
}
\end{lstlisting}

Die Methode \texttt{isValueObject} in Listing \ref{lst:suggestion:impl:refactor:change} zeigt den Quellcode welcher überprüft, ob es sich bei der übergebenen Entity um ein mögliches Value Object handelt. Dabei sind drei Kriterien zu erfüllen. In der zweiten Zeile wird überprüft, ob die Entity von einer anderen Entity erbt. Nur, wenn die Entity keine Superklasse besitzt, kann es sich um ein mögliches Value Object handeln. Das zweite Kriterium, welches erfüllt sein muss, steht in der vierten Zeile. Der Name des eines Attributs der Entity muss in dem Namen der Entity enthalten sein. Zusätzlich zu den bereits genannten Kriterien muss der Typ des Attributs ein Java Standardtyp sein. Dieses Kriterium wurde in der fünften Zeile realisiert.

\begin{figure}[ht]
    \centering
    \subfloat[Subfigure 1][ursprüngliches \\ Artefakt]{
        \includegraphics[width=0.2\textwidth]{gfx/example/ddd/uml-ddd-IssueComment-old.pdf}
        \label{fig:suggestion:impl:refactor:change:issuecomment:old}}
    \qquad \qquad
    \subfloat[Subfigure 2][verbessertes \\ Artefakt]{
        \includegraphics[width=0.2\textwidth]{gfx/example/ddd/uml-ddd-IssueComment-new.pdf}
        \label{fig:suggestion:impl:refactor:change:issuecomment:new}}
    \caption{Refactoring einer Entity zu einem Value Object}
    \label{fig:suggestion:impl:refactor:change:issuecomment}
\end{figure}

Die Abbildung \ref{fig:suggestion:impl:refactor:change:issuecomment} zeigt ein solches Beispiel. Das Beispiel stammt aus dem Abschnitt \ref{sec:anhang:beispiel:ddd} im Anhang. Die Entity \texttt{IssueComment} aus der Abbildung \ref{fig:suggestion:impl:refactor:change:issuecomment:old} verfügt nur über eine Identität und ein weiteres Attribut. Da alle, in Listing \ref{lst:suggestion:impl:refactor:change} beschriebenen Kriterien, erfüllt sind, wurde diese Entity als Value Object modelliert. Die Abbildung \ref{fig:suggestion:impl:refactor:change:issuecomment:new} zeigt das resultierende Value Object. Es verfügt nur noch über ein Attribut und auch die Methoden wurden an die Kriterien für Value Objects aus der Tabelle \ref{tab:rating:artifakt:value_object:criteria} angepasst.

\subsubsection{Erzeugung neuer Artefakte}
\label{sec:suggestion:impl:refactor:insert}
Das Hinzufügen von neuen Artefakten kann verschiedenen Gründe haben. Zum Beispiel sollte es zu jedem Repository Interface eine Implementierung geben, wenn diese nicht vorhanden ist, muss sie erzeugt werden.

\begin{lstlisting}[caption={Finden einer Interface-Implementierung}, captionpos=b, label=lst:suggestion:impl:refactor:insert:impl, language=my_java]
private Class getImpl(Package impl, Interface anInterface, DDDType dddType) {
  for (Artifact item : impl.getContains()) {
    if (item instanceof Class
          && item.isTypeOf(dddType)
          && ((Class) item).getImplInterfaces().contains(anInterface)) {
      return (Class) item;
    }
  }
  return null;
}
\end{lstlisting}

Mithilfe von der Methode \texttt{getImpl} aus Listing \ref{lst:suggestion:impl:refactor:insert:impl} findet der Umwandlungsalgorithmus Implementierungen eines Interfaces. Wenn eine passende Klasse gefunden wurde, wird diese zurückgegeben, andernfalls wird \texttt{null} zurückgegeben. Wenn es eine Implementierung gibt, wird diese, wie in Abschnitt \ref{sec:suggestion:impl:refactor:update} beschrieben, überarbeitet. Ist das nicht der Fall, muss eine Klasse erzeugt werden.

\begin{figure}[ht]
    \centering
    \subfloat[Subfigure 1][ursprüngliches \\ Artefakt]{
        \includegraphics[width=0.22\textwidth]{gfx/example/petclinic/uml-petclinic-PetRepository-old.pdf}
        \label{fig:suggestion:impl:refactor:insert:petrepository:old}}
    \qquad \qquad
    \subfloat[Subfigure 2][verbesserte \\ Artefakte]{
        \includegraphics[width=0.46\textwidth]{gfx/example/petclinic/uml-petclinic-PetRepository-new.pdf}
        \label{fig:suggestion:impl:refactor:insert:petrepository:new}}
    \caption{Erzeugung einer Interface-Implementierung}
    \label{fig:suggestion:impl:refactor:insert:petrepository}
\end{figure}

Die Abbildung \ref{fig:suggestion:impl:refactor:insert:petrepository:old} zeigt ein Repository-Interface. Allerdings verfügt das System über keine Implementierung des Interfaces, daher müsse diese vom Umwandlungsalgorithmus erzeugt werden. In Abbildung \ref{fig:suggestion:impl:refactor:insert:petrepository:new} ist das Ergebnis der Umwandlung zu sehen. Nachdem der Umwandlungsalgorithmus dem Repository-Interface notwendige Methoden hinzugefügt hat, wurde ein Klasse erzeugt, welche das Interface implementieren soll.

Auch bei der Überarbeitung einer Entity kann es passieren, dass ein neues Artefakt erzeugt werden muss. Da Entities keine Attribute eines Standardtyps besitzen sollten, müssen diese Attribute als Value Object repräsentiert werden. Dafür ist es erforderlich, dass der Umwandlungsalgorithmus die Möglichkeit besitzt neue Value Objects zu erzeugen, wenn sie benötigt werden.

\begin{lstlisting}[caption={Auslagern von Entity-Attributen in Value Objects}, captionpos=b, label=lst:suggestion:impl:refactor:insert:valueObject, language=my_java]
private void refactorFields(Package model, Class artifact) {
  for (Field field : artifact.getFields()) {
    if (!field.getType().contains("java.util.")) {
      File type = getTypeOfField(model, field);
      if (type != null) {
        field.setType(type.getPath());
      } else {
        Class newValueObject = createValueObjectByField(model, artifact, field);
        refactorField(artifact, field, newValueObject);
      }
    }
  }
}
\end{lstlisting}

Die Methode \texttt{refactorFields} aus Listing \ref{lst:suggestion:impl:refactor:insert:valueObject} überarbeitet die Attribute einer Entity. Wenn der Datentype eines Attributs ein Java Standardtyp ist, wird das Attribut angepasst. In der vierten Zeile wird nach einem vorhandenen Artefakt gesucht, welches das Attribut repräsentiert. Wenn ein Artefakt gefunden wurde, wird dieses als Datentyp übernommen. Andernfalls muss ein neues Artefakt erzeugt werden. Dies geschieht in der Methode, welche in der achten Zeile aufgerufen wird. Mithilfe des neuen Value Objects wird das Attribut und alle Methoden, welche das Attribut verwenden, überarbeitet.

\begin{figure}[H]
    \centering
    \subfloat[Subfigure 1][ursprüngliches \\ Artefakt]{
        \includegraphics[width=0.19\textwidth]{gfx/example/petclinic/uml-petclinic-BaseEntity-old.pdf}
        \label{fig:suggestion:impl:refactor:insert:baseentity:old}}
    \qquad \qquad
    \subfloat[Subfigure 2][verbesserte \\ Artefakte]{
        \includegraphics[width=0.46\textwidth]{gfx/example/petclinic/uml-petclinic-BaseEntity-new.pdf}
        \label{fig:suggestion:impl:refactor:insert:baseentity:new}}
    \caption{Attrribute einer Entity als Value Object auslagern}
    \label{fig:suggestion:impl:refactor:insert:baseentity}
\end{figure}

Die Abbildung \ref{fig:suggestion:impl:refactor:insert:baseentity} zeigt Ausschnitte der Abbildungen \ref{fig:anhang:petclinic:old} und \ref{fig:anhang:petclinic:new:domain:model}. Die Entity in Abbildung \ref{fig:suggestion:impl:refactor:insert:baseentity:old} besitzt ein Attribut welches die Identität der Entity repräsentiert, allerdings wurde dieses Attribut als \texttt{Integer} realisiert. Daher wurde dieses Attribut vom Umwandlungsalgorithmus als Value Object ausgelagert. 

\subsection{Aufräumen der neuen Architektur}
\label{sec:suggestion:impl:finalize}
Nach dem Verbessern aller Artefakte, werden verschiedenen Abschlussarbeiten ausgeführt. Dazu gehört zum Beispiel das Entfernen von leeren Modulen, welche in der ersten Phase, siehe Abschnitt \ref{sec:suggestion:impl:init}, erstellt aber nicht gefüllt wurden.

Außerdem werden die alten Abhängigkeiten an die neue Architektur angepasst. Das heißt, dass die Pfade, welche die Abhängigkeiten repräsentieren, durch die neuen Pfaden ersetzt werden.

\begin{lstlisting}[caption={Ersetzen der alten Abhängigkeiten durch die Neuen}, captionpos=b, label=lst:suggestion:impl:finalize:dependency, language=my_java]
private void refactorDependencies() {
  refactorData.getNewStructure().getClasses().stream()
    .parallel()
    .forEachOrdered(artifact -> {
      for (String dependency : new ArrayList<>(artifact.getDependencies())) {
        String[] split = dependency.split("[.]");
        String name = split[split.length - 1];
        String newPath = findNewPath(name);
        if (newPath != null) {
          artifact.getDependencies().remove(dependency);
          artifact.addDependencies(newPath);
        }
      }
    });
}
\end{lstlisting}

Die Methode in Listing \ref{lst:suggestion:impl:finalize:dependency} zeigt die Implementierung dieses Vorgangs. Diese Methode durchläuft alle Abhängigkeiten aller Klassen und ersetzt den alten Pfad durch einem neuen. Um den neuen Pfad zu finden, wird aus dem alten Pfad, in der sechsten und siebten Zeile, der Name des Artefakts extrahiert. Anschließend wird mit diesem Namen der neue Pfad gesucht und der Alte ersetzt.